[toc]

# APS (Algorithm Problem Solving) 응용

## 1. SW 문제 해결

프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력을 길러야 함!

- 문제를 읽고 이해하기
- 문제를 익숙한 용어로 재정의하기
- 어떻게 해결할지 계획 세우기
- 계획 검증하기
- 프로그램으로 구현하기
- 개선 방법 찾아보기

---

----

## 2. 복잡도 분석

### 효율성 

- 공간적 효율성: 연산량 대비 얼마나 적은 메모리 공간을 사용하는 가
- 시간적 효율성: 연산량 대비 얼마나 적은 시간을 사용하는 가

공간적 효율성과 시간적 효율성은 서로 **반비례 관계**



## 복잡도

효율성을 뒤집어 표현한 것!

- Big-O: 점근적 상한을 표시 / 가장 최악의 경우를 생각하는 것 --> 최대한으로 얼마나 걸리는 지 생각
- Big-Ω: 점근적 하한을 표시 / 가장 최상의 경우를 생각하는 것 --> 최소한으로 얼마나 걸리는 지 생각
- Big-θ: 평균적으로 얼마나 걸리는 지 생각

---

----

## 3. 표준 입출력 방법

늘상 쓰던 대로 `input()`, `print()` 사용하자!

파이썬에서는 f-string 으로 print 하는 것이 편함

```python
import sys
# input 값 외부에서 받아오고싶을 때 사용 / Console 내 input이 2M 이상이면 이 방법으로만 input
sys.stdin = open("input.txt", "r")
# 출력되는 값 외부에 저장하고싶을 때 사용
sys.stdout = open("output.txt", "w")
```

---

----

## 4. 비트 연산

### 계산

- & : 비트 단위로 AND 연산
- | : 비트 단위로 OR 연산
- ^ : 비트 단위로 XOR(서로 같으면 0, 다르면 1) 연산
- ~ (물결) : 단항 연산자 / 피연산자의 모든 비트 반전
- \<< : 피연산자의 비트 열을 왼쪽으로 이동 / 자릿수 증가시키는 것
- \>> : 피연산자의 비트 열을 오른쪽으로 이동 / 자릿수 감소시키는 것

```python
# 비트 연산 예제 : -5~5를 비트로 표현하기
def Bbit_print(i):
    output = ""
    for j in range(7,-1,-1):
        output += "1" if i & (1<<j) else "0"
    print(output)

for i in range(-5, 6):
    print("i = ", end='')
    Bbit_print(i)
```

```python
# 비트 연산 예제 2 : 주어진 16진수 값을 비트로 표현하기
def Bbit_print(i):
    output = ""
    for j in range(7,-1,-1):
        output += "1" if i & (1<<j) else "0"
    print(output, end=' ')

a = 0x10
x = 0x01020304
print(f"{a} = ", end='')
Bbit_print(a)
print()
print("0%x = " % x, end='')
for i in range(0, 4):
    Bbit_print((x >> i*8) & 0xff)
```



### 엔디안(Endianness)

컴퓨터의 메모리와 같은 1차운의 공간에서 여러 개의 연속된 대상을 배열하는 방법

- 빅 엔디안 : 큰 단위가 앞에 나옴
- 리틀 엔디안 : 작은 단위가 앞에 나옴

```python
'''
0x12345678의 경우
빅 엔디안 : 12 34 56 78 (높은 자리부터 순서대로)
리틀 엔디안: 78 56 34 12 (낮은 자리부터 순서대로)
* 한 숫자당 4bit 사용, 8bit를 1byte로 묶어서 다니기에 저렇게 숫자 두 개씩 묶이는 방식!

'''
```

```python
# 비트 연산 예제 3 : 엔디안 바꾸기

# 빅 엔디안으로 교체하는 함수
def ce(n):
    p = []
    for i in range(0, 4):
        p.append((n >> (24 - 8 * i)) & 0xff)
    return p

x = 0x01020304
p = []
# 이대로 진행하면 리틀 엔디안
for i in range(0,4):
    p.append((x >> (i*8)) & 0xff)

print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
p = ce(x)
print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
```

---

----

## 5. 진수

2진수, 8진수, 16진수를 주로 쓰게 될 것

**2진수(bin), 8진수(oct), 16진수(hex) -- > BOX**

2진수, 10진수, 16진수 등 진수 간 변환을 할 줄 알아야 한다!

```python
'''
예를 들어 10진수 88을 2진수, 16진수로 변환하고자 하면
88 = (1 * 2^6) + (0 * 2^5) + (1 * 2^4) + (1 * 2^3) + (0 * 2^2) + (0 * 2^1) + (0 * 2^0)
--> 88 = 1011000(2)

88 = (5 * 16^1) + (8 * 16^0)
--> 88 = 58(16)
'''
```



### 보수 표현법

- 컴퓨터(2진수) 에서의 음의 정수 표현 방법

  - 1의 보수: 부호와 절댓값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 전환

    0은 1로, 1은 0으로!

  - 2의 보수: 1의 보수 표현법에서 최하위 비트에 1을 더해준다!

---

----

## 6. 실수

### 실수의 표현

**부동 소수점(floating-point) 표기법** 사용!

부동 소수점 표기법? : 2진수가 있을 때 맨 앞에 1만 제외하고 소수점을 오른쪽으로 땡김

```python
'''
ex) 1001.0011(2) --> 1.0010011 * 2^3 처럼 만든다
'''
```

### 실수 저장하기 위한 방법

#### 1) 용어

- 가수부(mantissa): 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것

- 지수부(exponent): 실제 소수점의 위치를 지수 승으로 표현한 것

- 익세스(excess) 표현법: 지수부의 값을 반으로 나누어 그 갑슬 0으로 간주하여 음수지수, 양수지수를 표현          

  ​										하는 방법

#### 2) 형식

- 단정도 실수

  32비트 사용

  부호 1비트, 지수 8비트, 가수 23비트

  지수부분 만들 때 익세스 표현법 사용

  유효자릿수(십진수) : 6

- 배정도 실수

  64비트 사용

  부호 1비트, 지수 11비트, 가스 52비트

  유효자릿수(십진수) : 15