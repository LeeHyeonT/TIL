[toc]

# APS (Algorithm Problem Solving) 응용

## 1. SW 문제 해결

프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력을 길러야 함!

- 문제를 읽고 이해하기
- 문제를 익숙한 용어로 재정의하기
- 어떻게 해결할지 계획 세우기
- 계획 검증하기
- 프로그램으로 구현하기
- 개선 방법 찾아보기

---

----

## 2. 복잡도 분석

### 효율성 

- 공간적 효율성: 연산량 대비 얼마나 적은 메모리 공간을 사용하는 가
- 시간적 효율성: 연산량 대비 얼마나 적은 시간을 사용하는 가

공간적 효율성과 시간적 효율성은 서로 **반비례 관계**



## 복잡도

효율성을 뒤집어 표현한 것!

- Big-O: 점근적 상한을 표시 / 가장 최악의 경우를 생각하는 것 --> 최대한으로 얼마나 걸리는 지 생각
- Big-Ω: 점근적 하한을 표시 / 가장 최상의 경우를 생각하는 것 --> 최소한으로 얼마나 걸리는 지 생각
- Big-θ: 평균적으로 얼마나 걸리는 지 생각

---

----

## 3. 표준 입출력 방법

늘상 쓰던 대로 `input()`, `print()` 사용하자!

파이썬에서는 f-string 으로 print 하는 것이 편함

```python
import sys
# input 값 외부에서 받아오고싶을 때 사용 / Console 내 input이 2M 이상이면 이 방법으로만 input
sys.stdin = open("input.txt", "r")
# 출력되는 값 외부에 저장하고싶을 때 사용
sys.stdout = open("output.txt", "w")
```

---

----

## 4. 비트 연산

### 계산

- & : 비트 단위로 AND 연산
- | : 비트 단위로 OR 연산
- ^ : 비트 단위로 XOR(서로 같으면 0, 다르면 1) 연산
- ~ (물결) : 단항 연산자 / 피연산자의 모든 비트 반전
- \<< : 피연산자의 비트 열을 왼쪽으로 이동 / 자릿수 증가시키는 것
- \>> : 피연산자의 비트 열을 오른쪽으로 이동 / 자릿수 감소시키는 것

```python
# 비트 연산 예제 : -5~5를 비트로 표현하기
def Bbit_print(i):
    output = ""
    for j in range(7,-1,-1):
        output += "1" if i & (1<<j) else "0"
    print(output)

for i in range(-5, 6):
    print("i = ", end='')
    Bbit_print(i)
```

```python
# 비트 연산 예제 2 : 주어진 16진수 값을 비트로 표현하기
def Bbit_print(i):
    output = ""
    for j in range(7,-1,-1):
        output += "1" if i & (1<<j) else "0"
    print(output, end=' ')

a = 0x10
x = 0x01020304
print(f"{a} = ", end='')
Bbit_print(a)
print()
print("0%x = " % x, end='')
for i in range(0, 4):
    Bbit_print((x >> i*8) & 0xff)
```



### 엔디안(Endianness)

컴퓨터의 메모리와 같은 1차운의 공간에서 여러 개의 연속된 대상을 배열하는 방법

- 빅 엔디안 : 큰 단위가 앞에 나옴
- 리틀 엔디안 : 작은 단위가 앞에 나옴

```python
'''
0x12345678의 경우
빅 엔디안 : 12 34 56 78 (높은 자리부터 순서대로)
리틀 엔디안: 78 56 34 12 (낮은 자리부터 순서대로)
* 한 숫자당 4bit 사용, 8bit를 1byte로 묶어서 다니기에 저렇게 숫자 두 개씩 묶이는 방식!

'''
```

```python
# 비트 연산 예제 3 : 엔디안 바꾸기

# 빅 엔디안으로 교체하는 함수
def ce(n):
    p = []
    for i in range(0, 4):
        p.append((n >> (24 - 8 * i)) & 0xff)
    return p

x = 0x01020304
p = []
# 이대로 진행하면 리틀 엔디안
for i in range(0,4):
    p.append((x >> (i*8)) & 0xff)

print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
p = ce(x)
print("x = %d%d%d%d" % (p[0], p[1], p[2], p[3]))
```



## 5. 진수

## 6. 실수