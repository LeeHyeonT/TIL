[toc]

# Tree (트리)

## 1. 트리

한 개 이상의 노드로 이루어진 유한 집합

- 노드 중 최상위 노드를 root(루트) 라고 한다
- 나머지 노드들은 n개의 분리 집합 T1, ... , Tn 으로 분리될 수 있다
  - 서브 트리(subtree): 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  - T1, ... Tn 은 각각 하나의 트리가 되며 루트의 subtree(부 트리) 라 한다
- 형제 노드(slbling node): 같은 부모 노드의 자식 노드들
- 조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 자손 노드: 서브 트리에 있는 하위 레벨의 노드들

차수(degree)

- 노드의 차수: 노드에 연결된 자식 노드의 수
- 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
- 단말 노드(리프 노드): 차수가 0인 노드 --> 자식 노드가 없는 노드

높이

- 노드의 높이: 루트에서 노드에 이르는 간선의 수
- 트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값

---

----

## 2. 이진 트리

모든 노드들이 **2개의 서브트리** 를 갖는 특별한 형태의 트리

---> 각 노드가 자식 노드를 **최대 2개** 까지만 가질 수 있는 트리



### 이진 트리의 종류

#### 1) 포화 이진 트리(Full Binary Tree)

모든 레벨에 노드가 포화상태로 차 있는 이진 트리

**루트를 1번으로 하여 정해진 위치에 대한 노드 번호를 가짐**

#### 2) 완전 이진 트리(Complete Binary Tree)

높이가 h 이고 노드 수가 n개일 때, 포화 이진 트리의 **노드 번호 1번부터 n번까지 빈 자리가 없는** 이진 트리

--> 왼쪽부터 번호 순서대로 채워나가는 이진 트리

#### 3) 편향 이진 트리(Skewed Binary Tree)

높이 h에 대한 최소 갯수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

--> **왼쪽, 오른쪽 중에서 한 쪽으로만** 자식 노드를 계속 1개씩 가지는 트리



### 이진 트리에서의 순회(traversal)

순회: 트리의 각 노드를 빠짐없이, 중복되지 않게 전부 방문하는 것

#### 1) 전위순회(preorder traversal): VLR

부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 방문

왼쪽에 점 찍고 선 연결해볼 때의 순서

```python
# 함수를 만들어 재귀 방법으로 진행
'''
만약 그 자리에 무엇인가가 있다면
visit에 그 자리값을 넣어줌
그 이후 
1) 그 자리에서 왼쪽
2) 그 자리에서 오른쪽 
값을 차례로 재귀처리
'''
```



#### 2) 중위순회(inorder traversal): LVR

왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문

아래쪽에 점 찍고 선 연결해볼 때의 순서

```python
# 마찬가지로 함수를 만들어 재귀 방법으로 진행
'''
만약 그 자리에 무엇인가가 있다면
그 자리에서 왼쪽 재귀
그 이후
visit에 그 자리값을 넣어줌
그 이후
그 자리에서 오른쪽 재귀
'''
```



#### 3) 후위순회(postorder traversal): LRV

왼쪽 자식노드, 오른쪽 자식노드, 부모노드 순으로 방문

오른쪽에 점 찍고 선 연결해볼 때의 순서

```python
# 마찬가지로 함수를 만들어 재귀 방법으로 진행
'''
만약 그 자리에 무엇인가가 있다면
1) 그 자리에서 왼쪽
2) 그 자리에서 오른쪽
값을 차례로 재귀처리
그 이후
visit에 그 자리값을 넣어줌
'''
```



### 이진트리의 표현

이진 트리에 각 노드 번호를 **완전 이진 트리** 방식으로 부여!

노드 번호를 배열의 인덱스로 사용 / 인덱스는 0부터 시작하기에 첫 부분을 비워놔야한다!!



### 이진 트리의 저장

#### 1) 부모 번호를 인덱스로 자식 번호를 저장

​	기본적인 순회 진행할 때 쓰임

#### 2) 자식 번호를 인덱스로 부모 번호를 저장

​	root 찾기 / 특정 지점에서의 조상 찾기 할 때 쓰임



### 수식 트리

수식을 표현하는 트리

연산자는 root 노드거나 가지 노드 / 피연산자는 모두 leaf 노드

기본적으로 후위순회 사용!

---

----

## 3. 이진 탐색 트리

모든 원소는 **서로 다른 유일한 키** 를 가짐

key(왼쪽 subtree) < key(root 노드) < key(오른쪽 subtree)

왼쪽 subtree, 오른쪽 subtree 모두 이진 탐색 트리

**중위 순회** 하면 오름차순으로 정렬된 값 얻을 수 있음



### 연산법

root 에서 시작

탐색할 key 값 x 설정, 노드의 key값과 비교

- x = root key 값: 탐색연산 성공!
- x < root key 값: root 의 왼쪽 subtree 에 대해서 탐색연산 수행
- x > root key 값: root 의 오른쪽 subtree 에 대해서 탐색연산 수행

#### 1) 삽입

#### 2) 삭제

- 자식이 0개
- 자식이 1개
- 자식이 2개



### 성능

탐색, 삽입, 삭제의 경우 트리의 높이만큼 시간이 걸림: O(h)

(h: 트리의 높이(깊이))

평균적으로는 O(logn)

한쪽으로 치우친 경사 이진트리는 O(n)

---

----

## 4. 힙(heap)

**완전 이진 트리** 에 있는 노드 중에서 key 값이 가장 큰 노드나 key 값이 가장 작은 노드를 찾기 위해서 만든 자료구조

- 최대 힙(max heap)

  key 값이 가장 큰 노드를 찾기 위한 **완전 이진 트리**

  부모노드 key 값 > 자식노드 key 값

  root: key 값이 가장 큰 노드

- 최소 힙(min heap)

  key 값이 가장 작은 노드를 찾기 위한 **완전 이진 트리**

  부모노드 key 값 < 자식노드 key 값

  root: key 값이 가장 작은 노드



### 연산

####  1) 삽입

```python
# 맨 마지막 부분에 값 넣어주고
# 부모 노드와 값 비교
'''
부모 노드값 < 자식 노드값 이면
둘이 자리 바꾸고
아니면
그냥 그대로!
''
```

#### 2) 삭제

root 노드의 원소만을 삭제할 수 있음

힙의 종류에 따라 최댓값 혹은 최솟값을 구할 수 있음

---

----

# 기타

python 에서 heap 사용 시

```python
import heapq

heapq.heappop
heapq.heapify
.....
```

등등 사용한다!

다만 최소 힙의 경우만 되기에 최대 힙 사용하려면

주어지는 값에 - 붙여서 그 값과 원래 값 두개를 묶어 사용하면 된다!

--> a 라면 (-a, a) 사용하여 -a 이용해서 heapq 하고 값은 a 사용한다!